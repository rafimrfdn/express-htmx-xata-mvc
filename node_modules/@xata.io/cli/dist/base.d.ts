import { Command, Interfaces } from '@oclif/core';
import { Schemas, XataApiPlugin } from '@xata.io/client';
import { XataImportPlugin } from '@xata.io/importer';
import prompts from 'prompts';
import table from 'text-table';
import { ZodError } from 'zod';
import { ProjectConfig } from './config.js';
import { Profile } from './credentials.js';
declare const XataClient_base: import("@xata.io/client").ClientConstructor<{
    api: XataApiPlugin;
    import: XataImportPlugin;
}>;
export declare class XataClient extends XataClient_base {
}
export type APIKeyLocation = 'shell' | 'dotenv' | 'profile' | 'new';
export declare const ENV_FILES: string[];
export type Flags<T extends typeof Command> = Interfaces.InferredFlags<(typeof BaseCommand)['baseFlags'] & T['flags']>;
export type Args<T extends typeof Command> = Interfaces.InferredArgs<T['args']>;
export declare abstract class BaseCommand<T extends typeof Command> extends Command {
    #private;
    locale: string | undefined;
    timeZone: string | undefined;
    projectConfig?: ProjectConfig;
    projectConfigLocation?: string;
    apiKeyLocation?: APIKeyLocation;
    apiKeyDotenvLocation: string;
    searchPlaces: string[];
    static databaseURLFlag: {
        db: Interfaces.OptionFlag<string | undefined, Interfaces.CustomOptions>;
    };
    static branchFlag: Interfaces.OptionFlag<string | undefined, Interfaces.CustomOptions>;
    static yesFlag: {
        yes: Interfaces.BooleanFlag<boolean>;
    };
    static jsonFlag: {
        json: Interfaces.BooleanFlag<boolean>;
    };
    static commonFlags: {
        json: Interfaces.BooleanFlag<boolean>;
    };
    static baseFlags: {
        'no-input': Interfaces.BooleanFlag<boolean>;
        profile: Interfaces.OptionFlag<string | undefined, Interfaces.CustomOptions>;
    };
    static forceFlag(description?: string): {
        force: Interfaces.BooleanFlag<boolean>;
    };
    loadEnvFile(path: string): void;
    init(): Promise<void>;
    catch(err: Error & {
        exitCode?: number | undefined;
    }): Promise<any>;
    getProfile({ ignoreEnv }?: {
        ignoreEnv?: boolean;
    }): Promise<Profile>;
    getXataClient({ profile }?: {
        profile?: Profile;
    }): Promise<XataClient>;
    printTable(headers: string[], rows: string[][], align?: table.Options['align']): void;
    formatDate(date: string): string;
    info(message: string): void;
    success(message: string): void;
    verifyAPIKey(profile: Profile): Promise<undefined>;
    getWorkspace(options?: {
        allowCreate?: boolean;
    }): Promise<string>;
    getDatabase(workspace: string, options?: {
        allowCreate?: boolean;
    }): Promise<{
        name: string;
        region: string;
    }>;
    getBranch(workspace: string, region: string, database: string, options?: {
        allowEmpty?: boolean;
        allowCreate?: boolean;
        title?: string;
        defaultBranch?: string;
    }): Promise<string>;
    createDatabase(workspace: string, options?: {
        overrideName?: string;
        overrideRegion?: string;
    }): Promise<{
        name: string;
        region: string;
    }>;
    createBranch(workspace: string, region: string, database: string): Promise<string>;
    getDatabaseURL(databaseURLFlag?: string, allowCreate?: boolean): Promise<{
        databaseURL: string;
        source: 'flag' | 'config' | 'env' | 'interactive';
    }>;
    getParsedDatabaseURL(databaseURLFlag?: string, allowCreate?: boolean): Promise<{
        source: "env" | "flag" | "config" | "interactive";
        databaseURL: string;
        protocol: string;
        host: string;
        database: string;
        workspace: string;
        region: string;
    }>;
    parseDatabaseURL(databaseURL: string): {
        databaseURL: string;
        protocol: string;
        host: string;
        database: string;
        workspace: string;
        region: string;
    };
    getParsedDatabaseURLWithBranch(databaseURLFlag?: string, branchFlag?: string, allowCreate?: boolean): Promise<{
        branch: string;
        source: "env" | "flag" | "config" | "interactive";
        databaseURL: string;
        protocol: string;
        host: string;
        database: string;
        workspace: string;
        region: string;
    }>;
    getCurrentBranchName(): string;
    updateConfig(): Promise<undefined>;
    obtainKey(webHost: string): Promise<any>;
    deploySchema(workspace: string, region: string, database: string, branch: string, schema: Schemas.Schema): Promise<undefined>;
    printMigration(migration: {
        edits: Schemas.SchemaEditScript;
    }): void;
    printZodError(err: ZodError): void;
    prompt<name extends string>(options: prompts.PromptObject<name>, flagValue?: boolean | string): Promise<prompts.Answers<name>>;
    runCommand(command: string, args: string[]): Promise<unknown>;
    parseCommand(): Promise<{
        flags: Flags<T>;
        args: Args<T>;
        argv: string[];
    }>;
}
export {};
