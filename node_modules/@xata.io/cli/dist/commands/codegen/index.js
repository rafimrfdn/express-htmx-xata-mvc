var _a;
import { Flags } from '@oclif/core';
import { generate, isValidJavascriptTarget, javascriptTargets } from '@xata.io/codegen';
import chalk from 'chalk';
import { mkdir, readFile, writeFile } from 'fs/promises';
import path, { dirname, extname, relative } from 'path';
import { BaseCommand } from '../../base.js';
import { getBranchDetailsWithPgRoll } from '../../migrations/pgroll.js';
export const languages = {
    '.js': 'javascript',
    '.mjs': 'javascript',
    '.cjs': 'javascript',
    '.ts': 'typescript'
};
export const unsupportedExtensionError = (ext) => {
    return `Cannot generate code for a file with extension ${ext}. Please use one of the following extensions: ${Object.keys(languages).join(', ')}`;
};
class Codegen extends BaseCommand {
    async run() {
        var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const { flags } = await this.parseCommand();
        const output = flags.output || ((_c = (_b = this.projectConfig) === null || _b === void 0 ? void 0 : _b.codegen) === null || _c === void 0 ? void 0 : _c.output);
        const moduleType = (_e = (_d = this.projectConfig) === null || _d === void 0 ? void 0 : _d.codegen) === null || _e === void 0 ? void 0 : _e.moduleType;
        const javascriptTarget = flags['javascript-output-target'] || ((_g = (_f = this.projectConfig) === null || _f === void 0 ? void 0 : _f.codegen) === null || _g === void 0 ? void 0 : _g.javascriptTarget);
        if (!output) {
            return this.error(`Please, specify an output file as a flag or in your project configuration file first with ${chalk.bold('xata config set codegen.output <path>')}`);
        }
        if (javascriptTarget !== undefined && !isValidJavascriptTarget(javascriptTarget)) {
            return this.error(`Invalid javascript output target. Please use one of the following values: ${Object.keys(javascriptTargets).join(', ')}`);
        }
        const ext = extname(output);
        const dir = dirname(output);
        const language = languages[ext];
        if (!language) {
            return this.error(unsupportedExtensionError(ext));
        }
        const xata = await this.getXataClient();
        const { workspace, region, database, branch, databaseURL } = await this.getParsedDatabaseURLWithBranch(flags.db, flags.branch);
        const { schema } = await getBranchDetailsWithPgRoll(xata, { workspace, region, database, branch });
        const codegenBranch = flags['inject-branch'] ? branch : undefined;
        // Experimental: Keep the source code in the generated file and only update the parts that changed
        const incrementalBuild = (_l = (_h = flags['experimental-incremental-build']) !== null && _h !== void 0 ? _h : (_k = (_j = this.projectConfig) === null || _j === void 0 ? void 0 : _j.experimental) === null || _k === void 0 ? void 0 : _k.incrementalBuild) !== null && _l !== void 0 ? _l : false;
        const existingCode = incrementalBuild ? await readFile(output, 'utf8').catch(() => undefined) : undefined;
        const result = await generate({
            schema,
            databaseURL,
            language,
            moduleType,
            javascriptTarget,
            branch: codegenBranch,
            existingCode
        });
        const { typescript, javascript, types } = result;
        const code = language === 'typescript' ? typescript : javascript;
        await mkdir(dir, { recursive: true });
        await writeFile(output, code);
        if (types && (flags.declarations || ((_o = (_m = this.projectConfig) === null || _m === void 0 ? void 0 : _m.codegen) === null || _o === void 0 ? void 0 : _o.declarations))) {
            await writeFile(path.join(dir, 'types.d.ts'), types);
        }
        this.log(`Generated Xata code to ./${relative(process.cwd(), output)}`);
    }
    static async runIfConfigured(projectConfig, flags) {
        var _b;
        if ((_b = projectConfig === null || projectConfig === void 0 ? void 0 : projectConfig.codegen) === null || _b === void 0 ? void 0 : _b.output)
            return _a.run(flags !== null && flags !== void 0 ? flags : []);
    }
}
_a = Codegen;
Codegen.description = 'Generate code from the current database schema';
Codegen.examples = [];
Codegen.flags = {
    ..._a.commonFlags,
    ..._a.databaseURLFlag,
    branch: _a.branchFlag,
    output: Flags.string({
        char: 'o',
        description: 'Output file. Overwrites your project configuration setting'
    }),
    declarations: Flags.boolean({
        description: 'Whether or not the declarations file should be generated. Overwrites your project configuration setting'
    }),
    'inject-branch': Flags.boolean({
        description: 'Inject the branch name into the generated code. Useful if you have a build step and the branch name is not available at runtime'
    }),
    'javascript-output-target': Flags.string({
        description: 'The output target for the generated javascript code.'
    }),
    'worker-id': Flags.string({
        description: 'Xata worker deployment id'
    }),
    'experimental-incremental-build': Flags.boolean({
        description: 'Experimental: Keep the source code in the generated file and only update the parts that changed'
    })
};
Codegen.args = {};
export default Codegen;
