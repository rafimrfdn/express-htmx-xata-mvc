import Case from 'case';
import prettier from 'prettier';
import * as parserJavascript from 'prettier/parser-babel.js';
import * as parserTypeScript from 'prettier/parser-typescript.js';
import { Project, VariableDeclarationKind } from 'ts-morph';
import ts from 'typescript';
import { z } from 'zod';

const VERSION = "0.29.4";

function isValidJavascriptTarget(target) {
  return target !== void 0 && target in ts.ScriptTarget;
}
const javascriptTargets = Object.keys(ts.ScriptTarget).slice(Object.keys(ts.ScriptTarget).length / 2);
function getTypeName(tableName) {
  const name = Case.pascal(tableName);
  if (name.match(/^\d/))
    return `$${name}`;
  return name;
}
async function generate({
  databaseURL,
  branch,
  language,
  moduleType,
  javascriptTarget,
  schema,
  existingCode
}) {
  const project = new Project({
    useInMemoryFileSystem: true,
    compilerOptions: {
      module: moduleType === "cjs" ? ts.ModuleKind.CommonJS : ts.ModuleKind.ESNext,
      target: ts.ScriptTarget[javascriptTarget ?? "ES2020"]
    }
  });
  const sourceFile = project.createSourceFile("xata.ts", existingCode);
  const packageName = moduleType === "deno" ? "npm:@xata.io/client@latest" : "@xata.io/client";
  const packageImports = ["buildClient"];
  const typeImports = ["BaseClientOptions", "SchemaInference", "XataRecord"];
  const importDeclarations = sourceFile.getImportDeclarations().filter((i) => i.getModuleSpecifierValue() === packageName);
  const namedImports = importDeclarations.flatMap((i) => i.getNamedImports());
  for (const namedImport of namedImports) {
    if (packageImports.includes(namedImport.getName())) {
      namedImport.remove();
    } else if (typeImports.includes(namedImport.getName())) {
      namedImport.remove();
    }
  }
  for (const importDeclaration of importDeclarations) {
    if (importDeclaration.getNamedImports().length === 0) {
      importDeclaration.remove();
    }
  }
  const sdkImport = sourceFile.getImportDeclaration(
    (i) => i.getModuleSpecifierValue() === packageName && !i.isTypeOnly()
  );
  if (!sdkImport) {
    sourceFile.addImportDeclaration({
      namedImports: packageImports,
      moduleSpecifier: packageName,
      leadingTrivia: existingCode ? void 0 : `// Generated by Xata Codegen ${VERSION}. Please do not edit.
`
    });
  } else {
    const namedImports2 = /* @__PURE__ */ new Set([...sdkImport.getNamedImports().map((i) => i.getName()), ...packageImports]);
    sdkImport.removeNamedImports();
    sdkImport.addNamedImports([...namedImports2]);
  }
  const typesImport = sourceFile.getImportDeclaration(
    (i) => i.getModuleSpecifierValue() === packageName && i.isTypeOnly()
  );
  if (!typesImport) {
    sourceFile.addImportDeclaration({
      namedImports: typeImports,
      moduleSpecifier: packageName,
      isTypeOnly: true,
      trailingTrivia: "\n"
    });
  } else {
    const namedImports2 = /* @__PURE__ */ new Set([...typesImport.getNamedImports().map((i) => i.getName()), ...typeImports]);
    typesImport.removeNamedImports();
    typesImport.addNamedImports([...namedImports2]);
  }
  const tablesList = sourceFile.getVariableDeclaration("tables");
  const tablesListContent = `${JSON.stringify(schema.tables)} as const`;
  if (!tablesList) {
    sourceFile.addVariableStatement({
      declarationKind: VariableDeclarationKind.Const,
      declarations: [{ name: "tables", initializer: tablesListContent }],
      leadingTrivia: language === "javascript" ? `/** @typedef { import('./types').SchemaTables } SchemaTables */
             /** @type { SchemaTables } */
` : void 0,
      trailingTrivia: "\n"
    });
  } else {
    tablesList.setInitializer(tablesListContent);
  }
  const schemaTables = sourceFile.getTypeAlias("SchemaTables");
  const schemaTablesContent = `typeof tables`;
  if (!schemaTables) {
    sourceFile.addTypeAlias({ name: "SchemaTables", type: schemaTablesContent, isExported: true });
  } else {
    schemaTables.setType(schemaTablesContent);
  }
  const inferredTypes = sourceFile.getTypeAlias("InferredTypes");
  const inferredTypesContent = `SchemaInference<SchemaTables>`;
  if (!inferredTypes) {
    sourceFile.addTypeAlias({
      name: "InferredTypes",
      type: inferredTypesContent,
      isExported: true,
      trailingTrivia: "\n"
    });
  } else {
    inferredTypes.setType(inferredTypesContent);
  }
  const existingSchemaTypes = sourceFile.getTypeAliases().filter((t) => t.getName().endsWith("Record"));
  for (const type of existingSchemaTypes) {
    sourceFile.getTypeAlias(type.getName().replace(/Record$/, ""))?.remove();
    type.remove();
  }
  for (const table of schema.tables) {
    const typeName = getTypeName(table.name);
    sourceFile.addTypeAlias({
      name: typeName,
      type: `InferredTypes['${table.name}']`,
      isExported: true,
      leadingTrivia: "\n"
    });
    sourceFile.addTypeAlias({
      name: `${typeName}Record`,
      type: `${typeName} & XataRecord`,
      isExported: true
    });
  }
  const databaseSchema = sourceFile.getTypeAlias("DatabaseSchema");
  const databaseSchemaContent = `{
    ${schema.tables.map((table) => `'${table.name}': ${getTypeName(table.name)}Record`).join(",\n")}
  }`;
  if (!databaseSchema) {
    sourceFile.addTypeAlias({
      name: "DatabaseSchema",
      type: databaseSchemaContent,
      isExported: true,
      leadingTrivia: "\n"
    });
  } else {
    databaseSchema.setType(databaseSchemaContent);
  }
  const databaseClient = sourceFile.getVariableDeclaration("DatabaseClient");
  const databaseClientContent = `buildClient()`;
  if (!databaseClient) {
    sourceFile.addVariableStatement({
      declarationKind: VariableDeclarationKind.Const,
      declarations: [{ name: "DatabaseClient", initializer: databaseClientContent }],
      leadingTrivia: language === "javascript" ? `
/** @type { import('@xata.io/client').ClientConstructor<{}> } */
` : void 0,
      trailingTrivia: "\n"
    });
  } else {
    databaseClient.setInitializer(databaseClientContent);
  }
  const defaultOptions = sourceFile.getVariableDeclaration("defaultOptions");
  const defaultOptionsContent = JSON.stringify({ databaseURL, branch });
  if (!defaultOptions) {
    sourceFile.addVariableStatement({
      declarationKind: VariableDeclarationKind.Const,
      declarations: [{ name: "defaultOptions", initializer: defaultOptionsContent }],
      leadingTrivia: "\n"
    });
  } else {
    defaultOptions.setInitializer(defaultOptionsContent);
  }
  const xataClient = sourceFile.getClass("XataClient");
  if (!xataClient) {
    sourceFile.addClass({
      name: "XataClient",
      extends: "DatabaseClient<DatabaseSchema>",
      isExported: true,
      leadingTrivia: language === "javascript" ? `/** @typedef { import('./types').DatabaseSchema } DatabaseSchema */
               /** @extends DatabaseClient<DatabaseSchema> */
` : void 0,
      ctors: [
        {
          parameters: [
            {
              name: "options",
              type: "BaseClientOptions",
              hasQuestionToken: true
            }
          ],
          statements: `super({ ...defaultOptions, ...options }, tables);`
        }
      ]
    });
  }
  const xataClientInstance = sourceFile.getVariableDeclaration("instance");
  const getXataClient = sourceFile.getVariableDeclaration("getXataClient");
  if (!getXataClient) {
    if (!xataClientInstance) {
      sourceFile.addVariableStatement({
        declarationKind: VariableDeclarationKind.Let,
        declarations: [
          {
            name: "instance",
            initializer: "undefined",
            type: "XataClient | undefined"
          }
        ],
        trailingTrivia: "\n"
      });
    }
    sourceFile.addVariableStatement({
      declarationKind: VariableDeclarationKind.Const,
      declarations: [
        {
          name: "getXataClient",
          initializer: `() => {
              if (instance) return instance;

              instance = new XataClient();
              return instance;
            }`
        }
      ],
      isExported: true,
      leadingTrivia: language === "javascript" ? `
/** @type { () => XataClient } */
` : "\n",
      trailingTrivia: "\n"
    });
  }
  sourceFile.saveSync();
  project.emitSync();
  const typescript = prettier.format(sourceFile.getFullText(), {
    parser: "typescript",
    plugins: [parserTypeScript]
  });
  const javascript = prettier.format(project.getFileSystem().readFileSync("xata.js"), {
    parser: "babel",
    plugins: [parserJavascript]
  });
  const rawDeclarations = emitDeclarations(typescript);
  const types = rawDeclarations ? prettier.format(rawDeclarations, {
    parser: "typescript",
    plugins: [parserTypeScript]
  }) : void 0;
  return { typescript, javascript, types };
}
function emitDeclarations(code) {
  const files = /* @__PURE__ */ new Map();
  const inputFileName = "index.ts";
  const sourceFile = ts.createSourceFile(inputFileName, code, ts.ScriptTarget.ESNext);
  const compilerHost = {
    getSourceFile: (fileName) => fileName === inputFileName ? sourceFile : void 0,
    writeFile: (_name, _text) => {
    },
    getDefaultLibFileName: () => "lib.d.ts",
    useCaseSensitiveFileNames: () => false,
    getCanonicalFileName: (fileName) => fileName,
    getCurrentDirectory: () => "",
    getNewLine: () => "\n",
    fileExists: (fileName) => fileName === inputFileName,
    readFile: () => "",
    directoryExists: () => true,
    getDirectories: () => []
  };
  const program = ts.createProgram(
    ["index.ts"],
    { declaration: true, emitDeclarationOnly: true, removeComments: true },
    compilerHost
  );
  program.emit(void 0, (fileName, data) => files.set(fileName, data), void 0, true);
  return files.get("index.d.ts");
}

const columnSchema = z.lazy(
  () => z.object({
    name: z.string(),
    type: z.string(),
    unique: z.boolean().optional(),
    notNull: z.boolean().optional(),
    defaultValue: z.string().optional(),
    description: z.string().optional(),
    link: z.object({
      table: z.string()
    }).optional(),
    vector: z.object({
      dimension: z.number()
    }).optional(),
    file: z.object({
      defaultPublicAccess: z.boolean().optional()
    }).optional(),
    "file[]": z.object({
      defaultPublicAccess: z.boolean().optional()
    }).optional(),
    columns: z.array(columnSchema).optional()
  })
);
const revlinkSchema = z.object({
  table: z.string(),
  column: z.string()
});
const tableSchema = z.object({
  name: z.string(),
  columns: z.array(columnSchema),
  revLinks: z.array(revlinkSchema).optional()
});
const xataDatabaseSchema = z.object({
  tables: z.array(tableSchema)
});
const parseSchemaFile = (input) => {
  return xataDatabaseSchema.safeParse(JSON.parse(input));
};

export { columnSchema, generate, isValidJavascriptTarget, javascriptTargets, parseSchemaFile, revlinkSchema, tableSchema };
//# sourceMappingURL=index.mjs.map
