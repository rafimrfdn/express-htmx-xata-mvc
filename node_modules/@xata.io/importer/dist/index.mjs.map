{"version":3,"file":"index.mjs","sources":["../src/utils/email.ts","../src/utils/lang.ts","../src/columns.ts","../src/parsers/jsonParser.ts","../src/parsers/csvParser.ts","../src/csvStreamParser.ts","../src/utils/delay.ts","../src/importer.ts","../src/plugin.ts","../src/random-data.ts","../src/constants.ts"],"sourcesContent":["// Same as xata apis (removed a single `\\` to make it js compatible)\nconst EMAIL_REGEX =\n  /^[a-zA-Z0-9.!#$%&'*+\\\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\nexport function isValidEmail(email: string) {\n  return EMAIL_REGEX.test(email);\n}\n","import type { XataFile } from '@xata.io/client';\n\nexport function isDefined<T>(value: T | undefined | null): value is T {\n  return value !== undefined && value !== null;\n}\n\nexport function isObject<T>(value: T | unknown): value is T {\n  return isDefined(value) && typeof value === 'object';\n}\n\nexport function isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\nfunction notEmpty<T>(value: T | null | undefined): value is T {\n  return value !== null && value !== undefined;\n}\n\nexport function compact<T>(arr: Array<T | null | undefined>): T[] {\n  return arr.filter(notEmpty);\n}\n\nexport function isXataFile(value: unknown): value is XataFile {\n  return isObject(value) && (value as XataFile).base64Content !== undefined;\n}\n\nexport function partition<T>(array: T[], predicate: (item: T) => boolean): [T[], T[]] {\n  return array.reduce(\n    (acc, item) => {\n      acc[predicate(item) ? 0 : 1].push(item);\n      return acc;\n    },\n    [[], []] as [T[], T[]]\n  );\n}\n","import { Schemas, XataFile } from '@xata.io/client';\n\nimport AnyDateParser from 'any-date-parser';\nimport CSV from 'papaparse';\nimport { ColumnOptions, ToBoolean } from './types';\nimport { isValidEmail } from './utils/email';\nimport { compact, isDefined, isString } from './utils/lang';\n\nconst anyToDate = AnyDateParser.exportAsFunctionAny();\n\nconst isInteger = <T>(value: T): boolean => /^[-]?\\d+$/.test(String(value).trim());\n\nconst isFloat = <T>(value: T): boolean => /^[-]?\\d+(\\.\\d*)?$/.test(String(value).trim());\n\nconst isDateTime = <T>(value: T): boolean => anyToDate(value).invalid === undefined;\n\nconst isBoolean = <T>(value: T, toBoolean: ToBoolean): boolean => {\n  const toBooleanValue = toBoolean(value);\n  return isDefined(toBooleanValue) && [true, false].includes(toBooleanValue);\n};\n\nconst isEmail = <T>(value: T): boolean => isValidEmail(String(value).trim());\n\nconst isText = <T>(value: T): boolean =>\n  // Check for newlines\n  String(value).indexOf('\\n') >= 0 ||\n  // Check for long strings\n  String(value).length > 180;\n\nconst tryIsJsonArray = (string: string): boolean => {\n  try {\n    const parsed = JSON.parse(string);\n    return parsed.length > 0 && Array.isArray(parsed);\n  } catch (_error) {\n    return false;\n  }\n};\n\nconst tryIsCsvArray = (string: string): boolean => {\n  try {\n    return CSV.parse(string, { header: false }).errors.length === 0;\n  } catch (_error) {\n    return false;\n  }\n};\n\nconst parseMultiple = (value: string): string[] | null => {\n  if (tryIsJsonArray(value)) {\n    return JSON.parse(value) as string[];\n  }\n  return CSV.parse(value, { header: false }).data[0] as string[];\n};\n\nconst isGuessableMultiple = <T>(value: T): boolean => Array.isArray(value) || tryIsJsonArray(String(value));\n\nconst isGuessableVectorColumn = <T>(values: T[]): boolean => {\n  const checks = values.map((value) => {\n    const isMultiple = isGuessableMultiple(value);\n    if (!isMultiple) return null;\n\n    const array = parseMultiple(String(value)) ?? [];\n    if (array.some((item) => !isFloat(item))) return null;\n\n    return array.length;\n  });\n\n  return checks.every((length) => length !== null && length > 50);\n};\n\nconst isMultiple = <T>(value: T): boolean => isGuessableMultiple(value) || tryIsCsvArray(String(value));\n\nconst isMaybeMultiple = <T>(value: T): boolean => isMultiple(value) || typeof value === 'string';\n\nconst isDataUri = <T>(value: T): boolean => isString(value) && /(data:.*?;base64,.*?(?:[;,|]|$))/g.test(value);\n\n// should both of these be a function?\nconst defaultIsNull = (value: unknown): boolean => {\n  return !isDefined(value) || String(value).toLowerCase() === 'null' || String(value).trim() === '';\n};\n\nconst DEFAULT_BOOLEAN_VALUES = { true: ['true', 't', 'yes', 'y'], false: ['false', 'f', 'no', 'n'] };\n\nconst defaultToBoolean: ToBoolean = (value) => {\n  if (DEFAULT_BOOLEAN_VALUES.true.includes(String(value).trim().toLowerCase())) {\n    return true;\n  }\n  if (DEFAULT_BOOLEAN_VALUES.false.includes(String(value).trim().toLowerCase())) {\n    return false;\n  }\n  return null;\n};\n\nexport const guessColumnTypes = <T>(\n  columnValuesWithNulls: T[],\n  options: ColumnOptions = {}\n): Schemas.Column['type'] => {\n  const { isNull = defaultIsNull, toBoolean = defaultToBoolean } = options;\n  const columnValues = columnValuesWithNulls.filter((value) => !isNull(value));\n  if (columnValues.length === 0) {\n    return 'string';\n  }\n  if (columnValues.every((value) => isBoolean(value, toBoolean))) {\n    return 'bool';\n  }\n  // Integer needs to be checked before Float\n  if (columnValues.every(isInteger)) {\n    return 'int';\n  }\n  if (columnValues.every(isFloat)) {\n    return 'float';\n  }\n  if (columnValues.every(isDateTime)) {\n    return 'datetime';\n  }\n  if (columnValues.every(isEmail)) {\n    return 'email';\n  }\n  if (isGuessableVectorColumn(columnValues)) {\n    return 'vector';\n  }\n  if (columnValues.some(isGuessableMultiple)) {\n    return 'multiple';\n  }\n  if (columnValues.some((value) => isDataUri(value))) {\n    return 'file[]';\n  }\n  // text needs to be checked before string\n  if (columnValues.some(isText)) {\n    return 'text';\n  }\n  return 'string';\n};\n\nexport type CoercedValue = {\n  value: string | string[] | number | boolean | Date | null | XataFile | XataFile[];\n  isError: boolean;\n};\n\nexport const coerceValue = async (\n  value: unknown,\n  column: Schemas.Column,\n  options: ColumnOptions = {}\n): Promise<CoercedValue> => {\n  const { isNull = defaultIsNull, toBoolean = defaultToBoolean, proxyFunction } = options;\n\n  if (isNull(value)) {\n    return { value: null, isError: false };\n  }\n\n  switch (column.type) {\n    case 'string':\n    case 'text':\n    case 'link': {\n      return { value: String(value), isError: false };\n    }\n    case 'email': {\n      return isEmail(value) ? { value: String(value).trim(), isError: false } : { value: null, isError: true };\n    }\n    case 'int': {\n      return isInteger(value) || isFloat(value)\n        ? { value: parseInt(String(value), 10), isError: false }\n        : { value: null, isError: true };\n    }\n    case 'float': {\n      return isFloat(value) ? { value: parseFloat(String(value)), isError: false } : { value: null, isError: true };\n    }\n    case 'bool': {\n      const boolValue = toBoolean(value);\n      return { value: boolValue, isError: boolValue === null };\n    }\n    case 'datetime': {\n      const date = anyToDate(value);\n      return date.invalid ? { value: null, isError: true } : { value: date, isError: false };\n    }\n    case 'vector': {\n      if (!isMaybeMultiple(value)) return { value: null, isError: true };\n      const array = parseMultiple(String(value));\n\n      return {\n        value: array,\n        isError: array?.some((item) => !isFloat(item)) || array?.length !== column.vector?.dimension\n      };\n    }\n    case 'multiple': {\n      return isMaybeMultiple(value)\n        ? { value: parseMultiple(String(value)), isError: false }\n        : { value: null, isError: true };\n    }\n    case 'file': {\n      const file = await parseFile((value as string).trim(), proxyFunction);\n      if (!file) return { value: null, isError: true };\n\n      return { value: file, isError: false };\n    }\n    case 'file[]': {\n      // Regex in 3 parts to detect delimited strings of base64 data uris, URLs and local files\n      const items =\n        (value as string)\n          .match(/(data:.*?;base64,.*?(?:[;,|]|$))|(https?:\\/\\/.*?(?:[;,|]|$))|((?:file:\\/\\/)?.*?(?:[;,|]|$))/g)\n          ?.map((item) => item.replace(/[;,|]$/g, ''))\n          ?.filter((item) => item !== '') ?? [];\n\n      const files = await Promise.all(items.map((url) => parseFile(url, proxyFunction)));\n      const isError = files.some((file) => file === null);\n\n      return { value: compact(files), isError };\n    }\n    default: {\n      return { value: null, isError: true };\n    }\n  }\n};\n\nconst fetchFile = async (url: string) => {\n  const response = await fetch(url);\n  return await response.blob();\n};\n\nconst parseFile = async (url: string, request = fetchFile): Promise<XataFile | null> => {\n  const uri = url.trim();\n  try {\n    if (uri.startsWith('data:')) {\n      const [mediaType, base64Content] = uri.replace('data:', '').split(';base64,');\n      return new XataFile({ base64Content, mediaType });\n    } else if (uri.startsWith('http://') || uri.startsWith('https://')) {\n      const blob = await request(url);\n      return XataFile.fromBlob(blob);\n    } else {\n      const [fs, path] = await Promise.all(['fs', 'path'].map((name) => import(name)));\n      const filePath = path.resolve(uri.replace('file://', ''));\n      const blob = new Blob([fs.readFileSync(filePath)], { type: 'application/octet-stream' });\n      return XataFile.fromBlob(blob, { name: path.basename(filePath) });\n    }\n  } catch (error) {\n    console.log(error);\n    return null;\n  }\n};\n\nexport const coerceRows = async <T extends Record<string, unknown>>(\n  rows: T[],\n  columns: Schemas.Column[],\n  options?: ColumnOptions\n): Promise<Record<string, CoercedValue>[]> => {\n  const mapped = [];\n  for (const row of rows) {\n    const mappedRow: Record<string, CoercedValue> = {};\n    for (const column of columns) {\n      mappedRow[column.name] = await coerceValue(row[column.name], column, options);\n    }\n    mapped.push(mappedRow);\n  }\n  return mapped;\n};\n\nexport const guessColumns = <T extends Record<string, unknown>>(\n  rows: T[],\n  options?: ColumnOptions\n): Schemas.Column[] => {\n  const columnNames = new Set<string>(...rows.map((row) => Object.keys(row)));\n\n  return [...columnNames].map((columnName) => {\n    const values = rows.map((row) => row[columnName]);\n    const type = columnName === 'id' ? 'string' : guessColumnTypes(values, options);\n    return { name: columnName, type };\n  });\n};\n","import JSON from 'json5';\nimport { coerceRows, guessColumns } from '../columns';\nimport { ParseJsonOptions, ParseResults } from '../types';\nimport { isDefined, isObject, isXataFile, partition } from '../utils/lang';\nimport { Schemas } from '@xata.io/client';\n\nconst arrayToObject = (array: unknown[]) => {\n  return Object.fromEntries(array.map((value, index) => [index, value]));\n};\n\n// Some columns need to be prepared before coercing the rows\nconst prepareColumns = (columns: Schemas.Column[], values: { data: Record<string, unknown> }[]): Schemas.Column[] => {\n  return columns.map((column) => {\n    switch (column.type) {\n      case 'vector': {\n        // We get the dimension from the first row\n        const dimension = (values[0]?.data?.[column.name] as unknown[])?.length ?? 0;\n        return { ...column, vector: { dimension } };\n      }\n      default:\n        return column;\n    }\n  });\n};\n\nexport const parseJson = async (options: ParseJsonOptions, startIndex = 0): Promise<ParseResults> => {\n  const { data: input, columns: externalColumns, limit } = options;\n\n  const array = Array.isArray(input) ? input : isObject(input) ? [input] : JSON.parse(input);\n\n  const arrayUpToLimit = isDefined(limit) ? array.slice(0, limit) : array;\n  const columnsGuessed = externalColumns ?? guessColumns(arrayUpToLimit, options);\n  const item = await coerceRows(arrayUpToLimit, columnsGuessed, options);\n\n  const data = item.map((row, index) => {\n    const original = Array.isArray(arrayUpToLimit[index])\n      ? arrayToObject(arrayUpToLimit[index])\n      : arrayUpToLimit[index];\n\n    const errorKeys = Object.entries(row)\n      .filter(([_key, value]) => value.isError)\n      .map(([key]) => key);\n\n    const [files, data] = partition(\n      Object.entries(row).map(([key, item]) => [key, item.value]),\n      ([_key, value]) => isXataFile(value) || (Array.isArray(value) && value.some(isXataFile))\n    );\n\n    return {\n      data: Object.fromEntries(data),\n      files: Object.fromEntries(files),\n      original,\n      index: index + startIndex,\n      errorKeys\n    };\n  });\n\n  const columns = prepareColumns(columnsGuessed, data);\n\n  return { success: true, columns, warnings: [], data };\n};\n","import pick from 'lodash.pick';\nimport CSV, { ParseConfig } from 'papaparse';\nimport { ParseCsvOptions, ParseMeta, ParseResults } from '../types';\nimport { parseJson } from './jsonParser';\n\nexport const DEFAULT_CSV_DELIMITERS_TO_GUESS = [',', '\\t', '|', ';', '\\x1E', '\\x1F'];\n\n// https://github.com/sindresorhus/strip-bom/blob/main/index.js\nconst stripBom = (string: string) => {\n  if (typeof string !== 'string') {\n    throw new TypeError(`Expected a string, got ${typeof string}`);\n  }\n  // Catches EFBBBF (UTF-8 BOM) because the buffer-to-string\n  // conversion translates it to FEFF (UTF-16 BOM).\n  if (string.charCodeAt(0) === 0xfeff) {\n    return string.slice(1);\n  }\n  return string;\n};\n\nexport const metaToParseMeta = (meta: Papa.ParseMeta): Omit<ParseMeta, 'estimatedProgress' | 'rowIndex'> => ({\n  delimiter: meta.delimiter,\n  linebreak: meta.linebreak,\n  fields: meta.fields\n});\n\nexport const parseCsvOptionsToPapaOptions = (options: ParseCsvOptions): ParseConfig => {\n  const {\n    limit,\n    delimiter,\n    header = true,\n    skipEmptyLines = true,\n    delimitersToGuess = DEFAULT_CSV_DELIMITERS_TO_GUESS,\n    newline,\n    quoteChar = '\"',\n    escapeChar = '\"',\n    commentPrefix\n  } = options;\n  return {\n    header,\n    skipEmptyLines,\n    preview: limit,\n    delimiter,\n    delimitersToGuess,\n    newline,\n    quoteChar,\n    escapeChar,\n    comments: commentPrefix,\n    transformHeader(header) {\n      return stripBom(header);\n    }\n  };\n};\n\nconst dataForColumns = (data: unknown[], columns: ParseCsvOptions['columns']) => {\n  if (!columns) {\n    return data;\n  }\n  return data.map((d) =>\n    pick(\n      d,\n      columns.map((col) => col.name)\n    )\n  );\n};\n\nexport const papaResultToJson = async (\n  { data, errors }: CSV.ParseResult<unknown>,\n  options: ParseCsvOptions,\n  startIndex = 0\n): Promise<ParseResults> => {\n  const parseWarnings = errors.map((error) => error.message);\n\n  const jsonResults = await parseJson(\n    {\n      ...options,\n      data: dataForColumns(data, options.columns)\n    },\n    startIndex\n  );\n\n  return jsonResults.success\n    ? {\n        ...jsonResults,\n        warnings: [...parseWarnings, ...jsonResults.warnings]\n      }\n    : jsonResults;\n};\n","import chunkArray from 'lodash.chunk';\nimport PQueue from 'p-queue';\nimport Papa, { Parser, ParseResult } from 'papaparse';\nimport { metaToParseMeta, papaResultToJson, parseCsvOptionsToPapaOptions } from './parsers/csvParser';\nimport {\n  CsvResults,\n  OnBatchCallback,\n  ParseCsvOptions,\n  ParseCsvStreamBatchesOptions,\n  ParseCsvStreamOptions\n} from './types';\nimport { isDefined } from './utils/lang';\n\nconst CHUNK_SIZE = 1024 * 1024 * 10; // 10MB\n\n// https://github.com/mholt/PapaParse/issues/708 passing preview param to papaparse loads entire file in the browser\nexport const parseCsvStream = async ({ fileStream, parserOptions }: ParseCsvStreamOptions): Promise<CsvResults> => {\n  return new Promise((resolve, reject) => {\n    Papa.parse(fileStream, {\n      ...parseCsvOptionsToPapaOptions(parserOptions),\n      complete: async (papaResults) => {\n        const results = await papaResultToJson(papaResults, parserOptions);\n        resolve({ results, meta: { estimatedProgress: 1, rowIndex: 0, ...metaToParseMeta(papaResults.meta) } });\n      },\n      error: (error) => reject(error)\n    });\n  });\n};\n\nexport const parseCsvStreamBatches = async ({\n  fileStream,\n  fileSizeBytes,\n  parserOptions,\n  batchRowCount = 1000,\n  batchSizeMin = 10,\n  concurrentBatchMax = 5,\n  onBatch = () => new Promise((resolve) => resolve())\n}: ParseCsvStreamBatchesOptions): Promise<void> => {\n  let rowCount = 0;\n  let lastChunkProcessedRowCount = 0;\n  let averageCursorPerRow = 0;\n  let chunk: Papa.ParseResult<unknown> | null = null;\n  return new Promise((resolve, reject) => {\n    Papa.parse(fileStream, {\n      ...parseCsvOptionsToPapaOptions(parserOptions),\n      chunkSize: CHUNK_SIZE,\n      chunk: async (result: ParseResult<unknown>, parser: Parser) => {\n        try {\n          if (!chunk) {\n            chunk = result;\n          } else {\n            // cannot use push(...result.data) because stack size might be exceeded https://stackoverflow.com/a/61740952\n            for (const item of result.data) {\n              chunk.data.push(item);\n            }\n            chunk.meta = result.meta; // overwrite meta to be latest meta\n            for (const error of result.errors) {\n              chunk.errors.push(error);\n            }\n          }\n          const oldRowCount = rowCount;\n          rowCount += result.data.length;\n          averageCursorPerRow = result.meta.cursor / rowCount;\n\n          // Only stop papaparse from parsing the file if we have enough data to process\n          if (chunk.data.length >= batchRowCount * batchSizeMin) {\n            parser.pause();\n            chunk = await processPapaChunk({\n              papaChunk: chunk,\n              parser,\n              parserOptions,\n              batchRowCount,\n              averageCursorPerRow,\n              fileSizeBytes,\n              batchSizeMin,\n              concurrentBatchMax,\n              onBatch,\n              startRowIndex: lastChunkProcessedRowCount\n            });\n            lastChunkProcessedRowCount = oldRowCount;\n            parser.resume();\n          }\n        } catch (error) {\n          reject(error);\n          // abort after reject to avoid `complete` callback being called\n          parser.abort();\n        }\n      },\n      complete: async () => {\n        try {\n          if (chunk) {\n            await processPapaChunk({\n              papaChunk: chunk,\n              parserOptions,\n              batchRowCount,\n              averageCursorPerRow,\n              fileSizeBytes,\n              batchSizeMin,\n              concurrentBatchMax,\n              onBatch,\n              forceFinish: true,\n              startRowIndex: rowCount - chunk.data.length\n            });\n          }\n          resolve();\n        } catch (error) {\n          reject(error);\n        }\n      },\n      error: (error) => reject(error)\n    });\n  });\n};\n\nconst processBatch = async ({\n  data,\n  errors,\n  meta,\n  parserOptions,\n  parser,\n  onBatch,\n  fileSizeEstimateBytes,\n  startRowIndex\n}: {\n  data: unknown[];\n  errors: Papa.ParseError[];\n  meta: Papa.ParseMeta;\n  parserOptions: ParseCsvOptions;\n  parser?: Papa.Parser;\n  onBatch: OnBatchCallback;\n  fileSizeEstimateBytes: number;\n  startRowIndex: number;\n}) => {\n  const results = await papaResultToJson({ data, errors, meta: meta }, parserOptions, startRowIndex);\n  const estimatedProgress = meta.cursor / fileSizeEstimateBytes;\n\n  try {\n    await onBatch(results, { estimatedProgress, rowIndex: startRowIndex, ...metaToParseMeta(meta) });\n  } catch (error) {\n    // the user can throw an error to abort processing the file\n    parser?.abort();\n    throw error;\n  }\n};\n\nconst calcAmountToProcess = (\n  chunk: Papa.ParseResult<unknown>,\n  batchRowCount: number,\n  forceFinish: boolean,\n  batchSizeMin: number\n) => {\n  if (forceFinish) {\n    return chunk.data.length;\n  }\n  const chunks = Math.floor(chunk.data.length / batchRowCount);\n  if (chunks < batchSizeMin) {\n    return 0;\n  }\n  return chunks * batchRowCount;\n};\n\nconst processPapaChunk = async ({\n  papaChunk,\n  parser,\n  parserOptions,\n  batchRowCount,\n  averageCursorPerRow,\n  fileSizeBytes,\n  batchSizeMin,\n  concurrentBatchMax,\n  onBatch,\n  forceFinish = false,\n  startRowIndex\n}: {\n  papaChunk: Papa.ParseResult<unknown>;\n  parser?: Papa.Parser;\n  parserOptions: ParseCsvOptions;\n  batchRowCount: number;\n  averageCursorPerRow: number;\n  fileSizeBytes: number;\n  batchSizeMin: number;\n  concurrentBatchMax: number;\n  onBatch: OnBatchCallback;\n  forceFinish?: boolean;\n  startRowIndex: number;\n}): Promise<Papa.ParseResult<unknown>> => {\n  const amountToProcess = calcAmountToProcess(papaChunk, batchRowCount, forceFinish, batchSizeMin);\n\n  if (amountToProcess <= 0) {\n    return papaChunk;\n  }\n  const data = papaChunk.data.splice(0, amountToProcess);\n  const errors = papaChunk.errors.splice(0, amountToProcess);\n  const batches: unknown[][] = chunkArray(data, batchRowCount);\n  const promises = batches.map((batchData, index) => {\n    // cursor is how far through the file we are. Here we interpolate the cursor for the batches we are processing\n    const rowsSoFar = batchData.length + batchRowCount * index; //batchData.length and batchRowCount can be different\n    const rowsFromEnd = data.length - rowsSoFar;\n    const estimatedCursor = Math.floor(papaChunk.meta.cursor - averageCursorPerRow * rowsFromEnd);\n    const fileSizeEstimateBytes = isDefined(parserOptions.limit)\n      ? averageCursorPerRow * parserOptions.limit\n      : fileSizeBytes;\n    return () =>\n      processBatch({\n        data: batchData,\n        errors,\n        meta: { ...papaChunk.meta, cursor: estimatedCursor },\n        parserOptions,\n        parser,\n        onBatch,\n        fileSizeEstimateBytes,\n        startRowIndex: startRowIndex + batchRowCount * index\n      });\n  });\n  const queue = new PQueue({ concurrency: concurrentBatchMax, carryoverConcurrencyCount: true });\n  await queue.addAll(promises);\n  return papaChunk;\n};\n","export const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));\n","import { branchTransaction, putFile, XataPluginOptions } from '@xata.io/client';\nimport { ImportBatchOptions, ImportError, ImportFilesOptions, ImportLocation } from './types';\nimport { delay } from './utils/delay';\n\nexport const importBatch = async (\n  location: ImportLocation,\n  options: ImportBatchOptions,\n  pluginOptions: XataPluginOptions,\n  errors?: ImportError[],\n  maxRetries = 10,\n  retries = 0\n): Promise<{ ids: Array<string | null>; errors?: ImportError[] }> => {\n  const { batchRows } = options;\n  const operations = batchRows.map((row) => {\n    return {\n      insert: {\n        table: options.table,\n        record: row as { [key: string]: any }\n      }\n    };\n  });\n\n  try {\n    const { results } = await branchTransaction({\n      ...pluginOptions,\n      pathParams: {\n        workspace: location.workspace,\n        region: location.region,\n        dbBranchName: `${location.database}:${location.branch}`,\n        // @ts-expect-error For some reason, database is required...\n        database: location.database\n      },\n      body: { operations }\n    });\n\n    const ids = results.map((r) => ('id' in r ? r.id : null));\n\n    return { ids, errors };\n  } catch (error: any) {\n    if (error.errors) {\n      const rowErrors = error.errors.filter((e: any) => e.index !== undefined);\n      const errorRowIndexes = rowErrors.map((e: any) => e.index);\n      const rowsToRetry = batchRows.filter((_row, index) => !errorRowIndexes.includes(index));\n\n      // what if errors twice?\n      const errors = rowErrors.map((e: any) => ({ row: batchRows[e.index], error: e.message, index: e.index }));\n      return importBatch(location, { ...options, batchRows: rowsToRetry }, pluginOptions, errors, maxRetries, retries);\n    }\n    if (retries < maxRetries) {\n      // exponential backoff\n      await delay(1000 * 2 ** retries);\n      return importBatch(location, options, pluginOptions, errors, maxRetries, retries + 1);\n    }\n\n    throw error;\n  }\n};\n\nexport const importFiles = async (\n  location: ImportLocation,\n  options: ImportFilesOptions,\n  pluginOptions: XataPluginOptions\n) => {\n  const { workspace, database, region, branch } = location;\n  const { table, ids, files } = options;\n\n  for (const index in files) {\n    const row = files[index];\n    const record = ids[index];\n\n    for (const [columnName, value] of Object.entries(row)) {\n      const files = Array.isArray(value) ? value : [value];\n      for (const file of files) {\n        try {\n          await putFile({\n            ...pluginOptions,\n            pathParams: {\n              workspace: workspace,\n              // @ts-expect-error For some reason we need to send it\n              database: database,\n              branch: branch,\n              region: region,\n              tableName: table,\n              recordId: record ?? '',\n              columnName: columnName.trim()\n            },\n            body: file.toBlob(),\n            headers: { 'Content-Type': file.mediaType ?? 'application/octet-stream' }\n          });\n        } catch (error) {\n          console.log(error);\n        }\n      }\n    }\n  }\n};\n","import { XataPlugin, XataPluginOptions } from '@xata.io/client';\nimport { parseCsvStream, parseCsvStreamBatches } from './csvStreamParser';\nimport { importBatch, importFiles } from './importer';\nimport { ImportBatchOptions, ImportLocation, ImportFilesOptions } from './types';\n\nexport class XataImportPlugin extends XataPlugin {\n  build(pluginOptions: XataPluginOptions) {\n    return {\n      parseCsvStream,\n      parseCsvStreamBatches,\n      importBatch: (location: ImportLocation, options: ImportBatchOptions) =>\n        importBatch(location, options, pluginOptions),\n      importFiles: (location: ImportLocation, options: ImportFilesOptions) =>\n        importFiles(location, options, pluginOptions)\n    };\n  }\n}\n","import { fakerEN as faker } from '@faker-js/faker';\nimport { Schemas } from '@xata.io/client';\n\nexport function generateRandomData(table: Schemas.Table, size: number) {\n  const records: Record<string, unknown>[] = [];\n\n  for (let index = 0; index < size; index++) {\n    records.push(randomRecord(table.columns));\n  }\n\n  return records;\n}\n\nfunction randomRecord(columns: Schemas.Column[]) {\n  const record: Record<string, unknown> = {};\n  for (const column of columns) {\n    record[column.name] = randomData(column);\n  }\n  return record;\n}\n\nfunction randomData(column: Schemas.Column) {\n  switch (column.type) {\n    case 'text':\n      return faker.lorem.paragraphs(rand(2, 3));\n    case 'email':\n      return faker.internet.email({ provider: 'acme.pets' });\n    case 'int':\n      return rand(1, 100);\n    case 'float':\n      return rand(1, 10000) / rand(1, 100);\n    case 'bool':\n      return rand(0, 1) === 1;\n    case 'multiple':\n      return faker.word.words(rand(1, 3)).split(' ');\n    case 'string':\n      return randomString(column.name);\n    case 'datetime':\n      return faker.date.recent({ days: rand(1, 10) });\n    default:\n      return undefined;\n  }\n}\n\nfunction rand(min: number, max: number) {\n  return Math.floor(Math.random() * (max - min) + min);\n}\n\nconst generators: Record<string, () => string> = {\n  city: () => faker.location.city(),\n  country: () => faker.location.country(),\n  county: () => faker.location.county(),\n  state: () => faker.location.state(),\n  street: () => faker.location.street(),\n  timezone: () => faker.location.timeZone(),\n  tz: () => faker.location.timeZone(),\n  zipcode: () => faker.location.zipCode(),\n  zip: () => faker.location.zipCode(),\n  department: () => faker.commerce.department(),\n  product: () => faker.commerce.product(),\n  company: () => faker.company.name(),\n  firstName: () => faker.person.firstName(),\n  lastName: () => faker.person.lastName(),\n  phone: () => faker.phone.number('501-###-###')\n};\n\nfunction randomString(columnName: string) {\n  const gen = generators[columnName.toLowerCase()];\n  if (gen) return gen();\n  return faker.word.words(2);\n}\n","import { z } from 'zod';\n\n// We don't yet support importing all Xata column types\nexport const importColumnTypes = z.enum([\n  'bool',\n  'int',\n  'float',\n  'string',\n  'text',\n  'email',\n  'datetime',\n  'link',\n  'multiple',\n  'file',\n  'file[]',\n  'vector'\n]);\n"],"names":["isMultiple","JSON","data","item","header","Papa","errors","files","faker"],"mappings":"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"}