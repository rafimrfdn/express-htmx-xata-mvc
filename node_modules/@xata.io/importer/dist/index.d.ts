import { XataFile, Schemas, XataPlugin, XataPluginOptions } from '@xata.io/client';
import stream from 'stream';
import { z } from 'zod';

type WithRequired<T, K extends keyof T> = T & {
    [P in K]-?: T[P];
};
type Column = Schemas.Column;
type ToBoolean = (value: unknown) => boolean | null;
type ProxyFunction = (url: string) => Promise<Blob>;
type ColumnOptions = {
    /**
     * A function to check if a value is null.
     */
    isNull?: (value: unknown) => boolean;
    /**
     * A function to convert a value to a boolean. Should return true, false or null (not a boolean).
     */
    toBoolean?: ToBoolean;
    /**
     * Proxy function to use for environments that are not able to reach remote files due to CORS.
     * This function will be called with the remote file URL to be fetched.
     * */
    proxyFunction?: ProxyFunction;
};
type ParseCommonOptions = {
    /**
     * The schema of the columns to use for importing data.
     * If not provided, the columns will be guessed from the data.
     * If provided, the data will be coerced to the column types.
     */
    columns?: Column[];
    /**
     * Limit the number of rows to import.
     * @default // no limit
     * @min 1
     */
    limit?: number;
} & ColumnOptions;
type ParseCsvOptions = ParseCommonOptions & {
    /**
     * The delimiting character.
     * Leave blank to auto-detect from a list of most common delimiters, or any values passed in through `delimitersToGuess`.
     * Multi-character delimiters are supported.
     */
    delimiter?: string;
    /**
     * An array of delimiters to guess from if the delimiter option is not set.
     * @default [',', '\t', '|', ';', '\x1E', '\x1F']
     */
    delimitersToGuess?: string[];
    /**
     * If `true`, the first row of parsed data will be interpreted as field names.
     * Warning: Duplicate field names will overwrite values in previous fields having the same name.
     * @default true
     */
    header?: boolean;
    /**
     * If `true`, lines that are completely empty (those which evaluate to an empty string) will be skipped.
     * @default true
     */
    skipEmptyLines?: boolean;
    /**
     * The newline sequence. Leave blank to auto-detect. Must be one of `\r`, `\n`, or `\r\n`.
     * @default // auto-detect
     */
    newline?: '\r' | '\n' | '\r\n';
    /**
     * The character used to quote fields. The quoting of all fields is not mandatory. Any field which is not quoted will correctly read.
     * @default '"'
     */
    quoteChar?: string;
    /**
     * The character used to escape the quote character within a field.
     * If not set, this option will default to the value of `quoteChar`,
     * meaning that the default escaping of quote character within a quoted field is using the quote character two times.
     * (e.g. `"column with ""quotes"" in text"`)
     * @default '"'
     */
    escapeChar?: string;
    /**
     * A string that indicates a comment (for example, "#" or "//").
     * When we encounter a line starting with this string, it will skip the line.
     * @default // none
     */
    commentPrefix?: string;
};
type OnBatchCallback = (parseResults: ParseResults, meta: ParseMeta) => Promise<void>;
interface ParseStreamOptions<ParserOptions> {
    /**
     * The file to import.
     */
    fileStream: stream.Readable | File;
    /**
     * Additional options to pass to the parser.
     */
    parserOptions: ParserOptions;
}
type ParseCsvStreamOptions = ParseStreamOptions<ParseCsvOptions>;
type ParseCsvStreamBatchesOptions = {
    /**
     * The number of rows in a batch.
     * @default 1000
     */
    batchRowCount?: number;
    /**
     * The minimum number of rows for the csv parser to collect before processing batches.
     * @default 10
     */
    batchSizeMin?: number;
    /**
     * The maximum number of `onBatch` callbacks to run concurrently.
     * @default 5
     */
    concurrentBatchMax?: number;
    /**
     * Callback to run for each batch.
     */
    onBatch?: OnBatchCallback;
    /**
     * file size in bytes. Used to estimate progress
     */
    fileSizeBytes: number;
} & ParseStreamOptions<WithRequired<ParseCsvOptions, 'columns'>>;
type ImportFilesOptions = {
    table: string;
    ids: Array<string | null>;
    files: Array<ParseResultData['files']>;
};
type ParseMeta = {
    estimatedProgress: number;
    delimiter: string;
    linebreak: string;
    fields: string[] | undefined;
    rowIndex: number;
};
type ParseResultData = {
    data: Record<string, unknown>;
    files: Record<string, XataFile | XataFile[]>;
    original: unknown;
    index: number;
    errorKeys: string[];
};
type ParseResults = {
    success: true;
    columns: Column[];
    warnings: string[];
    data: ParseResultData[];
} | {
    success: false;
    errors: string[];
};
type CsvResults = {
    results: ParseResults;
    meta: ParseMeta;
};
type ImportBatchOptions = {
    columns: Column[];
    table: string;
    batchRows: unknown[];
};
type ImportLocation = {
    workspace: string;
    region: string;
    database: string;
    branch: string;
};
type ImportError = {
    row: unknown;
    error: string;
    index: number;
};

declare const guessColumnTypes: <T>(columnValuesWithNulls: T[], options?: ColumnOptions) => Schemas.Column['type'];

declare const DEFAULT_CSV_DELIMITERS_TO_GUESS: string[];

declare const parseCsvStream: ({ fileStream, parserOptions }: ParseCsvStreamOptions) => Promise<CsvResults>;
declare const parseCsvStreamBatches: ({ fileStream, fileSizeBytes, parserOptions, batchRowCount, batchSizeMin, concurrentBatchMax, onBatch }: ParseCsvStreamBatchesOptions) => Promise<void>;

declare class XataImportPlugin extends XataPlugin {
    build(pluginOptions: XataPluginOptions): {
        parseCsvStream: ({ fileStream, parserOptions }: ParseCsvStreamOptions) => Promise<CsvResults>;
        parseCsvStreamBatches: ({ fileStream, fileSizeBytes, parserOptions, batchRowCount, batchSizeMin, concurrentBatchMax, onBatch }: ParseCsvStreamBatchesOptions) => Promise<void>;
        importBatch: (location: ImportLocation, options: ImportBatchOptions) => Promise<{
            ids: (string | null)[];
            errors?: ImportError[] | undefined;
        }>;
        importFiles: (location: ImportLocation, options: ImportFilesOptions) => Promise<void>;
    };
}

declare function generateRandomData(table: Schemas.Table, size: number): Record<string, unknown>[];

declare const importColumnTypes: z.ZodEnum<["bool", "int", "float", "string", "text", "email", "datetime", "link", "multiple", "file", "file[]", "vector"]>;

declare function isValidEmail(email: string): boolean;

export { type CsvResults, DEFAULT_CSV_DELIMITERS_TO_GUESS, type ImportBatchOptions, type ImportError, type ParseCsvStreamBatchesOptions, type ParseCsvStreamOptions, type ParseMeta, type ParseResultData, type ParseResults, XataImportPlugin, generateRandomData, guessColumnTypes, importColumnTypes, isValidEmail, parseCsvStream, parseCsvStreamBatches };
